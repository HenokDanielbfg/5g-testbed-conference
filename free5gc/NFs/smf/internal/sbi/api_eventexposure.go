/*
 * Nsmf_EventExposure
 *
 * Session Management Event Exposure Service API
 *
 * API version: 1.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package sbi

import (
	"net/http"
	"strconv"

	// "time"

	"github.com/free5gc/openapi"
	"github.com/free5gc/openapi/models"

	// "github.com/free5gc/smf/internal/context"
	"github.com/free5gc/smf/internal/context"
	smf_context "github.com/free5gc/smf/internal/context"
	"github.com/free5gc/smf/internal/logger"

	// "github.com/free5gc/util/idgenerator"

	"github.com/gin-gonic/gin"
)

func (s *Server) getEventExposureRoutes() []Route {
	return []Route{
		{
			Method:  http.MethodGet,
			Pattern: "/",
			APIFunc: func(c *gin.Context) {
				c.JSON(http.StatusOK, gin.H{"status": "Service Available"})
			},
		},
		{
			Method:  http.MethodPost,
			Pattern: "subscriptions",
			APIFunc: s.SubscriptionsPost,
		},
		{
			Method:  http.MethodDelete,
			Pattern: "subscriptions/:subId",
			APIFunc: s.SubscriptionsSubIdDelete,
		},
		{
			Method:  http.MethodGet,
			Pattern: "subscriptions/:subId",
			APIFunc: s.SubscriptionsSubIdGet,
		},
		{
			Method:  http.MethodPut,
			Pattern: "subscriptions/:subId",
			APIFunc: s.SubscriptionsSubIdPut,
		},
	}
}

// SubscriptionsPost -
func (s *Server) SubscriptionsPost(c *gin.Context) {
	// c.JSON(http.StatusNotImplemented, gin.H{})
	// type createEventSubscription struct {
	// Subscription      *models.NsmfEventExposure `json:"subscription" bson:"subscription" `
	// SupportedFeatures string                `json:"supportedFeatures,omitempty" bson:"supportedFeatures" `
	// }
	var createEventSubscription models.NsmfEventExposure
	requestBody, err := c.GetRawData()
	if err != nil {
		logger.SBILog.Errorf("Get Request Body error: %+v", err)
		problemDetail := models.ProblemDetails{
			Title:  "System failure",
			Status: http.StatusInternalServerError,
			Detail: err.Error(),
			Cause:  "SYSTEM_FAILURE",
		}
		c.JSON(http.StatusInternalServerError, problemDetail)
		return
	}
	err = openapi.Deserialize(&createEventSubscription, requestBody, "application/json")
	if err != nil {
		problemDetail := err.Error()
		rsp := models.ProblemDetails{
			Title:  "Malformed request syntax",
			Status: http.StatusBadRequest,
			Detail: problemDetail,
		}
		logger.SBILog.Errorln(problemDetail)
		c.JSON(http.StatusBadRequest, rsp)
		return
	}
	HandleCreateSMFEventSubscription(c, createEventSubscription)
}

// SubscriptionsSubIdDelete -
func (s *Server) SubscriptionsSubIdDelete(c *gin.Context) {
	// c.JSON(http.StatusNotImplemented, gin.H{})
	logger.SBILog.Infoln("Handle Delete SMF Event Subscription")

	subscriptionID := c.Param("subId")

	problemDetails := DeleteAMFEventSubscriptionProcedure(subscriptionID)
	if problemDetails != nil {
		c.JSON(int(problemDetails.Status), problemDetails)
	} else {
		c.JSON(http.StatusOK, nil)
	}
}

func DeleteAMFEventSubscriptionProcedure(subscriptionID string) *models.ProblemDetails {
	smfSelf := smf_context.GetSelf()

	subscription, ok := smfSelf.FindEventSubscription(subscriptionID)
	if !ok {
		problemDetails := &models.ProblemDetails{
			Status: http.StatusNotFound,
			Cause:  "SUBSCRIPTION_NOT_FOUND",
		}
		return problemDetails
	} else {
		logger.SBILog.Infof("subscription found with ID %s:", subscription.SubId)
	}
	smfSelf.DeleteEventSubscription(subscriptionID)
	// smfSelf.EventSubscriptions.Delete(subscriptionID)
	// if id, err := strconv.ParseInt(subscriptionID, 10, 32); err != nil {
	// 	logger.SBILog.Error(err)
	// } else {
	// 	smfSelf.EventSubscriptionIDGenerator.FreeID(id)
	// }
	return nil
}

// SubscriptionsSubIdGet -
func (s *Server) SubscriptionsSubIdGet(c *gin.Context) {
	c.JSON(http.StatusNotImplemented, gin.H{})
}

// SubscriptionsSubIdPut -
func (s *Server) SubscriptionsSubIdPut(c *gin.Context) {
	c.JSON(http.StatusNotImplemented, gin.H{})
}

// type SmfEventSubscription struct {
// 	Subscription      *models.NsmfEventExposure `json:"subscription" bson:"subscription" `
// 	SupportedFeatures string                    `json:"supportedFeatures,omitempty" bson:"supportedFeatures" `
// }

// type SMFContextEventSubscription struct {
// 	EventSubscription models.NsmfEventExposure
// 	IsAnyUe           bool
// 	IsGroupUe         bool
// 	UeSupiList        []string
// 	Expiry            string
// }

// type SmfUeEventSubscription struct {
// 	EventSubscription *models.NsmfEventExposure
// 	Timestamp         time.Time
// 	RemainReports     *int32
// 	AnyUe             bool
// }

// type SmfCreateEventSubscription struct {
// 	Subscription *SmfEventSubscription `json:"subscription"`
// }

// type SmfCreatedEventSubscription struct {
// 	Subscription   *models.NsmfEventExposure `json:"subscription"`
// 	SubscriptionId string                    `json:"subscriptionId"`
// 	// ReportList     []SmfEventReport          `json:"reportList,omitempty"`
// }

// type SmfEventSubscriptions struct {
// 	SubscriptionsList []*SmfCreatedEventSubscription `json:"eventList"`
// 	// AnyUE     bool       `json:"anyUe"`
// 	Supi    string `json:"supi,omitempty"`
// 	GroupId string `json:"groupId,omitempty"`
// }

// type SmfEvent struct {
// 	Type         string `json:"type"`
// 	ImmediateFlag bool   `json:"immediateFlag"`
// }

// type SmfSubscriptionOptions struct {
// 	Expiry    string `json:"expiry,omitempty"`
// 	MaxReports int32 `json:"maxReports,omitempty"`
// 	Trigger    string `json:"trigger,omitempty"`
// }

// type SmfEventReport struct {
// 	EventType string       `json:"eventType"`
// 	State     *ReportState `json:"state,omitempty"`
// }

// type ReportState struct {
// 	Active bool `json:"active"`
// }

// var SmfSubs SmfEventSubscriptions

func HandleCreateSMFEventSubscription(c *gin.Context,
	createEventSubscription models.NsmfEventExposure,
) {
	createdEventSubscription, problemDetails := CreateSMFEventSubscriptionProcedure(createEventSubscription)
	if createdEventSubscription != nil {
		c.JSON(http.StatusCreated, createdEventSubscription)
	} else if problemDetails != nil {

		c.JSON(int(problemDetails.Status), problemDetails)
	} else {
		problemDetails = &models.ProblemDetails{
			Status: http.StatusInternalServerError,
			Cause:  "UNSPECIFIED_NF_FAILURE",
		}
		c.JSON(http.StatusInternalServerError, problemDetails)
	}
}

func CreateSMFEventSubscriptionProcedure(createEventSubscription models.NsmfEventExposure) (
	*models.NsmfEventExposure, *models.ProblemDetails,
) {
	smfSelf := context.GetSelf()
	createdEventSubscription := &context.SmfCreatedEventSubscription{}
	subscription := &createEventSubscription
	// contextEventSubscription := &SMFContextEventSubscription{}
	// contextEventSubscription.EventSubscription = *subscription

	// var isImmediate bool
	// var immediateFlags []bool
	// var reportList []models.SmfEventReport
	// generator := &idgenerator.IDGenerator{} // Using pointer
	// generator := idgenerator.NewGenerator(1, 1000)
	// id, err := generator.Allocate()
	// if err != nil {
	// 	problemDetails := &models.ProblemDetails{
	// 		Status: http.StatusInternalServerError,
	// 		Cause:  "UNSPECIFIED_NF_FAILURE",
	// 	}
	// 	return nil, problemDetails
	// }
	// newSubscriptionID := strconv.Itoa(int(id))

	id, err := smfSelf.EventSubscriptionIDGenerator.Allocate()
	if err != nil {
		problemDetails := &models.ProblemDetails{
			Status: http.StatusInternalServerError,
			Cause:  "UNSPECIFIED_NF_FAILURE",
		}

		return nil, problemDetails
	}
	newSubscriptionID := strconv.Itoa(int(id))

	// ueEventSubscription := SmfUeEventSubscription{
	// 	EventSubscription: &contextEventSubscription.EventSubscription,
	// 	Timestamp:         time.Now().UTC(),
	// }

	// if subscription.Options != nil && subscription.Options.Trigger == "CONTINUOUS" {
	// 	ueEventSubscription.RemainReports = new(int32)
	// 	*ueEventSubscription.RemainReports = subscription.Options.MaxReports
	// }

	if subscription.EventSubs == nil {
		problemDetails := &models.ProblemDetails{
			Status: http.StatusBadRequest,
			Cause:  "SUBSCRIPTION_EMPTY",
		}
		return nil, problemDetails
	}

	// for _, events := range subscription.EventSubs {
	// 	immediateFlags = append(immediateFlags, events.ImmediateFlag)
	// 	if events.ImmediateFlag {
	// 		isImmediate = true
	// 	}
	// }

	if subscription.AnyUeInd {
		createdEventSubscription.Subscription = &createEventSubscription
		createdEventSubscription.SubscriptionId = newSubscriptionID
		subscription.SubId = newSubscriptionID
		smfSelf.SmfSubs.SubscriptionsList = append(smfSelf.SmfSubs.SubscriptionsList, createdEventSubscription)
		// smfSelf.EventSubscriptions.Store(newSubscriptionID, subscription)
		smfSelf.NewEventSubscription(newSubscriptionID, subscription)
		logger.SBILog.Info("new smf subscription added")
		// contextEventSubscription.IsAnyUe = true
		// ueEventSubscription.AnyUe = true
		// smfSelf.UePool.Range(func(key, value interface{}) bool {
		// 	ue := value.(*context.SmfUe)
		// 	ue.Lock.Lock()
		// 	defer ue.Lock.Unlock()
		// 	ue.EventSubscriptionsInfo[newSubscriptionID] = &ueEventSubscription
		// 	contextEventSubscription.UeSupiList = append(contextEventSubscription.UeSupiList, ue.Supi)
		// 	return true
		// })
	} else if subscription.GroupId != "" {
		// contextEventSubscription.IsGroupUe = true
		// ueEventSubscription.AnyUe = true
		// smfSelf.UePool.Range(func(key, value interface{}) bool {
		// 	ue := value.(*context.SmfUe)
		// 	ue.Lock.Lock()
		// 	defer ue.Lock.Unlock()
		// 	if ue.GroupID == subscription.GroupId {
		// 		ue.EventSubscriptionsInfo[newSubscriptionID] = &ueEventSubscription
		// 		contextEventSubscription.UeSupiList = append(contextEventSubscription.UeSupiList, ue.Supi)
		// 	}
		// 	return true
		// })
	} else {
		// if ue, ok := smfSelf.SmfUeFindBySupi(subscription.Supi); !ok {
		// 	problemDetails := &models.ProblemDetails{
		// 		Status: http.StatusForbidden,
		// 		Cause:  "UE_NOT_SERVED_BY_SMF",
		// 	}
		// 	return nil, problemDetails
		// } else {
		// 	ue.Lock.Lock()
		// 	defer ue.Lock.Unlock()
		// 	ue.EventSubscriptionsInfo[newSubscriptionID] = &ueEventSubscription
		// 	contextEventSubscription.UeSupiList = append(contextEventSubscription.UeSupiList, ue.Supi)
		// }
	}

	// if subscription.Options != nil {
	// 	contextEventSubscription.Expiry = subscription.Options.Expiry
	// }
	// smfSelf.NewEventSubscription(newSubscriptionID, contextEventSubscription)

	// createdEventSubscription.Subscription = subscription
	// createdEventSubscription.SubscriptionId = newSubscriptionID

	// if subscription.AnyUE {
	// 	smfSelf.UePool.Range(func(key, value interface{}) bool {
	// 		ue := value.(*context.SmfUe)
	// 		ue.Lock.Lock()
	// 		defer ue.Lock.Unlock()
	// 		if isImmediate {
	// 			p.subReports(ue, newSubscriptionID)
	// 		}
	// 		for i, flag := range immediateFlags {
	// 			if flag {
	// 				report, ok := p.newSmfEventReport(ue, subscription.EventList[i].Type, newSubscriptionID)
	// 				if ok {
	// 					reportList = append(reportList, report)
	// 				}
	// 			}
	// 		}
	// 		return true
	// 	})
	// } else {
	// 	// Similar logic for GroupId or single UE as above
	// }

	// if len(reportList) > 0 {
	// 	createdEventSubscription.ReportList = reportList
	// }

	return subscription, nil

}
